<?xml version="1.0" encoding="UTF-8"?>
<protocol name="org_kde_kwin_output_management">
  <copyright><![CDATA[
        Copyright © 2015 Sebastian Kügler <sebas@kde.org>
        Copyright © 2008-2011 Kristian Høgsberg
        Copyright © 2010-2011 Intel Corporation
        Copyright © 2012-2013 Collabora, Ltd.

        Permission to use, copy, modify, distribute, and sell this
        software and its documentation for any purpose is hereby granted
        without fee, provided that the above copyright notice appear in
        all copies and that both that copyright notice and this permission
        notice appear in supporting documentation, and that the name of
        the copyright holders not be used in advertising or publicity
        pertaining to distribution of the software without specific,
        written prior permission.  The copyright holders make no
        representations about the suitability of this software for any
        purpose.  It is provided "as is" without express or implied
        warranty.

        THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
        FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
        SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
        AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
        ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
        THIS SOFTWARE.
        ]]></copyright>

  <interface name="org_kde_kwin_output_management" version="1">
    <description summary="list connected, but disabled outputs">
    This interface allows to connected output devices for screen configuration purposes.

    - keep protocol flat for simplicity, use id to tell which output this signal refers to
    - provide info about all outputs, per OutputDevice:

    events:
    - outputdevice_added
        - id (unique int, only handed out by kwin, used to identify and refer to an OD throughout the protocol)
        - resolution: resX, resY
        - position: posX, posY
        - orientation: degree
        - primary: bool
        - enabled: bool
    - modes: width, height, refresh_rate (separate signal)
    - edid: eisa_id, monitor_name, serial_number, physical_width, physical_height (separate signal)
    - outputdevice_removed: id

    methods:
    - per outputdevice:
        - set enabled
        - set mode
        - set orientation
        - set position
        - set primary
    - apply: client is done sending set* calls, "dear compositor, please apply the settings now"


    server:
        - wayland_server.cpp gets a OutputManagement interface
        - initOutputs also triggers events in the screenmanagement interface
        - announces the outputs on the OutputManagementInterface when bound
        - sends device announced, edid and mode callbacks in order
        - solely responsible for handing out ids
        - is responsible for state changes through backends
        - decides what to do with the information

    client:
        - connects to server
        - receives the info about all the outputs
        - ignores wl_output otherwise
        - can set properties of outputs (enable/disable, mode, position, etc.)

    why?
        - keeps everything in one place
        - one interface for a specific purpose
        - bi-directional, so defined config interface, no config writing/picking up etc.
        - one place to housekeep ids
        - interface is purpose-made, not trying to shoe-horn kscreen in and around wl_output
        - server really seems to be the right place to keep state and logic
        - makes concertation less complex, since there's exactly one place to handle state, like mode, on/off, etc.


    </description>

    <event name="disabled_output_added">
      <description summary="emitted when anutp output is connected">
        The output is connected, but not used for rendering yet. This means that
        this output has either just been plugged in, or disabled and excluded from
        the registry object.
      </description>
      <arg name="edid" type="string" summary="the outputs EDID string"/>
      <arg name="name" type="string" summary="output's name"/>
      <arg name="connector" type="string" summary="output's connector"/>
    </event>

    <event name="disabled_output_removed">
      <description summary="emitted when an output disappears from the list">
        The output is disconnected, or has been enabled.
      </description>
      <arg name="name" type="string" summary="output's name"/>
      <arg name="connector" type="string" summary="output's connector"/>
    </event>


    <event name="outputdevice_added">
        <description summary="emitted when an output is connected">
            The output is connected, but not used for rendering yet. This means that
            this output has either just been plugged in, or disabled and excluded from
            the registry object.
        </description>
        <arg name="id" type="int" summary="the unique output's device ID"/>
        <arg name="width" type="int" summary="current resolution's height in pixel"/>
        <arg name="height" type="int" summary="current resolution's width in pixel"/>
        <arg name="x" type="int" summary="the outputs EDID string"/>
        <arg name="y" type="int" summary="output's name"/>
        <arg name="enabled" type="int" summary="is the output currently used to display screen content?"/>
        <arg name="primary" type="int" summary="is the output the primary display?"/>
        <arg name="rotation" type="int" summary="output rotation in degree"/>
    </event>

    <event name="edid">
        <description summary="emitted when an output disappears from the list">
            EDID information for an output is announced.
        </description>
        <arg name="id" type="int" summary="the ID of the output for this EDID information"/>
        <arg name="eisa_id" type="string" summary="EISA ID of the output device"/>
        <arg name="monitor_name" type="string" summary="human-readable name of the output device"/>
        <arg name="serial_number" type="string" summary="serial number of the output device"/>
        <arg name="physical_width" type="int" summary="physical width in millimeter"/>
        <arg name="physical_height" type="int" summary="physical height in millimeter"/>
    </event>

    <event name="mode">
        <description summary="emitted per mode and per outputdevice">
            A new mode is announced for a given output.
        </description>
        <arg name="id" type="int" summary="the ID of the output this mode applies to"/>
        <arg name="width" type="int" summary="horizontal resolution in pixels"/>
        <arg name="height" type="int" summary="vertical resolution in pixels"/>
        <arg name="refresh_rate" type="int" summary="human-readable name of the output device"/>
    </event>

    <event name="outputdevice_removed">
        <description summary="emitted when an output disappears from the list">
            The output is disconnected or otherwise gone.
        </description>
        <arg name="id" type="int" summary="output's id"/>
    </event>

    <event name="done">
        <description summary="emitted after all initial events have been fired">
            This event is fired once the listing of outputdevices triggered after binding
            the protocol is done, i.e. after all outputs, their edid and their modes have
            been announced. In case there are no outputdevices, this event is fired anyway.
        </description>
    </event>

</interface>

<interface name="org_kwin_outputdevice" version="2">
    <description summary="compositor output region">
        An output describes part of the compositor geometry.  The
        compositor works in the 'compositor coordinate system' and an
        output corresponds to rectangular area in that space that is
        actually visible.  This typically corresponds to a monitor that
        displays part of the compositor space.  This object is published
        as global during start up, or when a monitor is hotplugged.
    </description>

    <enum name="subpixel">
        <description summary="subpixel geometry information">
            This enumeration describes how the physical
            pixels on an output are laid out.
        </description>
        <entry name="unknown" value="0"/>
        <entry name="none" value="1"/>
        <entry name="horizontal_rgb" value="2"/>
        <entry name="horizontal_bgr" value="3"/>
        <entry name="vertical_rgb" value="4"/>
        <entry name="vertical_bgr" value="5"/>
    </enum>

    <enum name="transform">
        <description summary="transform from framebuffer to output">
            This describes the transform that a compositor will apply to a
            surface to compensate for the rotation or mirroring of an
            output device.

            The flipped values correspond to an initial flip around a
            vertical axis followed by rotation.

            The purpose is mainly to allow clients render accordingly and
            tell the compositor, so that for fullscreen surfaces, the
            compositor will still be able to scan out directly from client
            surfaces.
        </description>

        <entry name="normal" value="0"/>
        <entry name="90" value="1"/>
        <entry name="180" value="2"/>
        <entry name="270" value="3"/>
        <entry name="flipped" value="4"/>
        <entry name="flipped_90" value="5"/>
        <entry name="flipped_180" value="6"/>
        <entry name="flipped_270" value="7"/>
    </enum>

    <event name="geometry">
        <description summary="properties of the output">
            The geometry event describes geometric properties of the output.
            The event is sent when binding to the output object and whenever
            any of the properties change.
        </description>
        <arg name="x" type="int"
             summary="x position within the global compositor space"/>
        <arg name="y" type="int"
             summary="y position within the global compositor space"/>
        <arg name="physical_width" type="int"
             summary="width in millimeters of the output"/>
        <arg name="physical_height" type="int"
             summary="height in millimeters of the output"/>
        <arg name="subpixel" type="int"
             summary="subpixel orientation of the output"/>
        <arg name="make" type="string"
             summary="textual description of the manufacturer"/>
        <arg name="model" type="string"
             summary="textual description of the model"/>
        <arg name="transform" type="int"
             summary="transform that maps framebuffer to output"/>
        </event>

        <enum name="mode">
            <description summary="mode information">
                These flags describe properties of an output mode.
                They are used in the flags bitfield of the mode event.
            </description>
            <entry name="current" value="0x1"
                   summary="indicates this is the current mode"/>
            <entry name="preferred" value="0x2"
                   summary="indicates this is the preferred mode"/>
            </enum>

            <event name="mode">
                <description summary="advertise available modes for the output">
                    The mode event describes an available mode for the output.

                    The event is sent when binding to the output object and there
                    will always be one mode, the current mode.  The event is sent
                    again if an output changes mode, for the mode that is now
                    current.  In other words, the current mode is always the last
                    mode that was received with the current flag set.

                    The size of a mode is given in physical hardware units of
                    the output device. This is not necessarily the same as
                    the output size in the global compositor space. For instance,
                    the output may be scaled, as described in org_kwin_outputdevice.scale,
                    or transformed , as described in org_kwin_outputdevice.transform.
                </description>
                <arg name="flags" type="uint" summary="bitfield of mode flags"/>
                <arg name="width" type="int" summary="width of the mode in hardware units"/>
                <arg name="height" type="int" summary="height of the mode in hardware units"/>
                <arg name="refresh" type="int" summary="vertical refresh rate in mHz"/>
            </event>

            <event name="done" since="2">
                <description summary="sent all information about output">
                    This event is sent after all other properties has been
                    sent after binding to the output object and after any
                    other property changes done after that. This allows
                    changes to the output properties to be seen as
                    atomic, even if they happen via multiple events.
                </description>
            </event>

            <event name="scale" since="2">
                <description summary="output scaling properties">
                    This event contains scaling geometry information
                    that is not in the geometry event. It may be sent after
                    binding the output object or if the output scale changes
                    later. If it is not sent, the client should assume a
                    scale of 1.

                    A scale larger than 1 means that the compositor will
                    automatically scale surface buffers by this amount
                    when rendering. This is used for very high resolution
                    displays where applications rendering at the native
                    resolution would be too small to be legible.

                    It is intended that scaling aware clients track the
                    current output of a surface, and if it is on a scaled
                    output it should use wl_surface.set_buffer_scale with
                    the scale of the output. That way the compositor can
                    avoid scaling the surface, and the client can supply
                    a higher detail image.
                </description>
                <arg name="factor" type="int" summary="scaling factor of output"/>
            </event>
        </interface>



</protocol>
